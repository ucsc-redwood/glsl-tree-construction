#version 450
#extension GL_KHR_shader_subgroup_basic:enable
#extension GL_KHR_shader_subgroup_ballot:enable
#extension GL_KHR_shader_subgroup_arithmetic:enable
#extension GL_KHR_shader_subgroup_vote:enable
#extension GL_EXT_debug_printf:require
#extension GL_EXT_shader_explicit_arithmetic_types_int8:enable

#define IDX gl_GlobalInvocationID.x

layout(set=0,binding=0)uniform Constants{
    uint num_brt_nodes;
};

layout(set=0,binding=1)buffer BrtNodes{
    uint morton_codes[];
    bool hasLeaf[];
    uint8_t prefixN[];
    int lefChild[];
    int parent[];
    
}brt_nodes;

layout(set=0,binding=2)buffer RadixTree{
    int n_pts;// number of points (n = number of Unique morton codes)
    int n_nodes;// number of radix tree nodes (n - 1)
    float min_coord;
    float max_coord;
}radix_tree;

void k_BuildRadixTree(){
    if(IDX <num_brt_nodes ){
        const uint code_i= brt_nodes.morton_codes[IDX];
        // Determine direction of the range (+1 or -1)
        int d;
        if(i==0){
            d=1;
        }else{
            const uint delta_diff_right=delta_u32(code_i,codes[i+1]);
            const uint delta_diff_left=delta_u32(code_i,codes[i-1]);
            const uint direction_difference=delta_diff_right-delta_diff_left;
            d=(direction_difference>0)-(direction_difference<0);
        }
        
        // Compute upper bound for the length of the range
        
        int l=0;
        if(i==0){
            // First node is root, covering whole tree
            l=n-1;
        }else{
            const uint delta_min=delta_u32(code_i,codes[i-d]);
            int l_max=2;
            // Cast to ptrdiff_t so in case the result is negative (since d is +/- 1),
            // we can catch it and not index out of bounds
            while(i+static_cast<std::ptrdiff_t>(l_max)*d>=0&&
            i+l_max*d<=n&&
            delta_u32(code_i,codes[i+l_max*d])>delta_min){
                l_max*=2;
            }
            const auto l_cutoff=(d==-1)?i:n-i;
            int t;
            int divisor;
            // Find the other end using binary search
            for(t=l_max/2,divisor=2;t>=1;
            divisor*=2,t=l_max/divisor){
                if(l+t<=l_cutoff&&
                    delta_u32(code_i,codes[i+(l+t)*d])>delta_min){
                        l+=t;
                    }
                }
            }
            
            const auto j=i+l*d;
            
            // Find the split position using binary search
            const auto delta_node=delta_u32(codes[i],codes[j]);
            prefix_n[i]=delta_node;
            auto s=0;
            const auto max_divisor=1<<log2_ceil_u32(l);
            auto divisor=2;
            const auto s_cutoff=(d==-1)?i-1:n-i-1;
            for(auto t=ceil_div_u32(l,2);divisor<=max_divisor;
            divisor<<=1,t=ceil_div_u32(l,divisor)){
                if(s+t<=s_cutoff&&
                    delta_u32(code_i,codes[i+(s+t)*d])>delta_node){
                        s+=t;
                    }
                }
                
                // Split position
                const auto gamma=i+s*d+std::min(d,0);
                left_child[i]=gamma;
                has_leaf_left[i]=(std::min(i,j)==gamma);
                has_leaf_right[i]=(std::max(i,j)==gamma+1);
                // Set parents of left and right children, if they aren't leaves
                // can't set this node as parent of its leaves, because the
                // leaf also represents an internal node with a differnent parent
                if(!has_leaf_left[i]){
                    parent[gamma]=i;
                }
                if(!has_leaf_right[i]){
                    parent[gamma+1]=i;
                }
            }
        }